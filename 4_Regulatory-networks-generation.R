# Useful info:
# In this part of regulatory network inference, this script prepares the objects in order
# to plot the network. For this case study, the GSE4607 gene network will be used, along 
# with the GSE26378 genetic signature.

# Chunk 1: Load necessary data and packages. ####
# 1) These RDatas were generated by a previous script (3_Regulatory-network-reconstruction.R)
load("~/chunk2_dataRTN_signatureGSE26378.RData")
load("~/chunk3_TNI-TNA_analysis_GSE4607.RData")
library(RTN) # From Bioconductor
library(RedeR) # From Bioconductor
library(data.table) # From CRAN
library(RColorBrewer) # From CRAN
library(classInt) # From CRAN

# 1.1) Disclaimer: the mr_list object is an character vector of the TFs of interest.
# These TFs were selected based on several filtering on the data (i.e., useful for my research), 
# and it is not mandatory to use the *same* TFs herein listed. Take them as an example.
mr_list <- c("ZNF331","KLF12","RORA","ZNF544","GATA3","ZNF551","IRF4","GCFC2",
                     "ZNF253","ZNF529","ZNF235","SMAD3","TULP4","NKRF","ZNF234",
                     "ZNF706","NR3C2","ZNF141","ZNF10","NFE2L3","REXO4","DBP","ZNF134",
                     "ZKSCAN8","ZNF202","ZNF329","HOXB2","ZBTB25","CIITA","ZNF510",
                     "SOX12","ZNF16","JUNB","TRIM25","PHTF1","MAFG","EPAS1","KLF5",
                     "KLF7","MEF2A","MTF1","NFIL3","GAS7","CEBPB","HES1","FOSL2",
                     "ZNF467","BCL6","RFX2")
# 1.2) This command shorten the tna data.frame (which contains all potential master regulators)
# and gets information only for the TFs present in the mr_list.
mra <- subset(tna, tna$Regulon%in%mr_list)
# 1.3) This chunk of code below is a temporary solution. Basically it assigns p-values = 1 to all TFs,
# except for the master regulators (which will be colored in the network based on its real adjusted p-value). 
# 1.3.1) Gets a temporary vector of master regulators of interest probe IDs.
PROBEID <- rownames(mra)
# 1.3.2) Deletes rownames of mra object.
rownames(mra) <- NULL
# 1.3.3) Paste together the probe IDs (as a column, not the rownames) and the rest of the data.frame mra.
mra <- cbind(PROBEID,mra)
# 1.3.5) Set names for columns of interest (in this case, just three).
colnames(mra)[c(1,2,9)] <- c("PROBEID", "SYMBOL","Adjusted.Pvalue")
# 1.3.6) This is where the magic happens: this step selects the master regulators from the phenoIDs data.frame,
# assigning it to an index variable, which will be used in step 1.4.8.
idx <- which(dataRTN$phenoIDs$SYMBOL%in%mra$SYMBOL)
# 1.3.7) Then, the master regulators in the index variable are removed, creating a new temp data.frame with two columns.
temp <- dataRTN$phenoIDs[-idx,c(1,3)]
# 1.3.8) Set the names of these columns as PROBEID and SYMBOL. Check the result with the View() function.
colnames(temp) <- c("PROBEID","SYMBOL")
# 1.3.9) Another cat's leap: creates a column within the temp data.frame, and assigning all values to 1. 
# This column will represent the adjusted p-value for all regulons. It is necessary because the colors on the 
# network will represent the adjusted p-value of the master regulator analysis, so instead of colouring all regulons,
# only the selected ones will be shown with color. 
temp$Adjusted.Pvalue <- 1
# 1.3.10) The other part of the magic: from the mra data.frame, get only the columns present in the temp data.frame.
temp2 <- mra[,c("PROBEID","SYMBOL","Adjusted.Pvalue")]
# 1.3.11) Paste (rowise) the two temporary data.frames. This way, now the dataset is complete again, with p-values for non master regulators set to 1 and the original
# adjusted p-value for the master regulators.
temp3 <- rbind(temp,temp2)
# 1.3.12) Now, remains get the p-values range, in order to create the breaks for colors. First, get only the =/= 1 values.
pv_range <- subset(temp3,temp3$SYMBOL%in%mr_list)
# 1.3.13) Keep only the p-value column, turning into a numeric vector. 
pv_range <- pv_range$Adjusted.Pvalue
# 1.3.14) Appending the numeric 1 to the set of values, in order to create a rank from min(pv_range) to 1.
pv_range <- append(pv_range,values = 1)

# Chunk 2: igraph object preparation ####
# This chunk prepares the graph to be visualized by RedeR package. It is mandatory to have all packages loaded from start.
# 2.1) First things first: the function to automatize this is under construction; for now, it is still manual. The first command
# maps the igraph object to an data.frame. This will be used for setting aliases to respective probe ids and its p-values.
# The command takes as first argument the graph (g) from the igraph object created in 3_Regulatory-network-reconstruction.R. 
# I know, a graph inception. 
talGSE4607 <- att.mapv(GSE4607_tree$g, dat=temp3, refcol=1)
# 2.2) This command is setting the gene symbols as node aliases; otherwise, the aliases would be the rownames (i.e., probe ids).
talGSE4607 <- att.setv(g=talGSE4607, from="SYMBOL", to="nodeAlias")
# 2.3) Then the color pallete is created. For this example, it is used yellow-orange-red, from low to high significance, respectively.
# The number of colors is set to 6, but could be more (less is not recommended).
color.code <- brewer.pal(n = 6,name = "YlOrRd")
# 2.4) As the pallete say "Yellow-Orange-Red". From default, the package would take it from the higher to lower significance, respectively.
# What is wanted here is: more significant (more negative value) = red; less significative (more positive or 1) = gray.
# So, to get the pallete the way for work, simply reverts its order. Notice that there is no "gray" color (nor its HEX code).
color.code <- rev(color.code)
# 2.5) The gray color is added here, replacing the white-yellowish color. 
color.code[6] <- "#BDBDBD"
# 2.6.1) The breaks are created from a package classInt. This way it will divide the p-values in categories, according to its range.
breaks <- classIntervals(var = pv_range[1:length(pv_range)],n = 5,rtimes = 3)
# 2.6.2) Then breaks are stored in a unique variable, to be used...
breaks <- breaks$brks
# 2.6.3) ...here. Is the same command as in 2.2, just setting another parameter to the graph.
talGSE4607 <- att.setv(g=talGSE4607,from="Adjusted.Pvalue", 
                        to="nodeColor",breaks=breaks,pal=2,cols = color.code)

# Chunk 3: Network visualization ####
# This chunk follows the basic RedeR procedure to visualize networks. Check if you have Java running on your computer (or server).
# Linux = $ java --version (To install java, check your distro repos for openjdk packages)
# Windows = Seriously? I mean... Just check if it is in the installed programs.
# Mac = I think the same way Linux does.
# 3.1) Creates a port to communicate R and Java.
rdp <- RedPort()
# 3.2) Open this port and brings up the GUI.
calld(rdp)
# 3.3) Literally adds to the rdp the talGSE4607 graph, with (almost) all parameters set previously.
addGraph(rdp,talGSE4607)
# 3.4) Force network relax, changing some parameters (in GUI, use the ctrl + X to check the relaxing parameters).
relax(rdp,p1=50,p5=20)
# 3.5) The series of commands below adds elements to the graph in the RedeR GUI.
# 3.5.1) Every step of elements addition is for nodes only. In tree-and-leaf representations, mostly the information
# of edges is not taken into account (like edge width). First, then, the scale of node color is added to a variable;
scl <- talGSE4607$legNodeColor$scale
# 3.5.2) Then, the same is done for the legend of node COLOR.
leg <- talGSE4607$legNodeColor$legend
# 3.5.3) Finally, the legends start appearing on the side of network. First, the legend of node color. 
addLegend.color(rdp, colvec=scl, labvec=leg, title="node color (Adjusted p-value)")
# 3.5.4) For node SIZE, the same is done. The same object was used as variables, but feel free to modify that.
# There is no impact on the result. First, assign the scale
scl <- talGSE4607$legNodeSize$scale
# 3.5.5) Then the legend per se.
leg <- as.character(round(as.numeric(talGSE4607$legNodeSize$legend)))
# 3.5.6) Finally, the legend for node size is plotted (in another extremity). To see more about the parameters, see the 
# help for this function.
addLegend.size(rdp, sizevec=scl, labvec=leg, title="node size (Regulon size)",
               position="bottomright", intersp=10,ftsize=10,vertical=F)

# 3.6) Personal comment: i was just lazy to click "relax". It was not making me relax at all. 
for(i in 1:100000){relax(rdp,p1=65,p5=20)}
rm(i)

# Chunk 4: check regulated genes ####
# First things first: It is necessary to extract an object from the rtni object: the tnet. This "sub-object"
# contains the regulatory network for the inputted data. Then, only the information of the 49 previously selected
# master regulators (stored in mr_list) will be retrieved.
# (personal comment: "Started thinking that -MAYBE- i'm using 'first things first' a lot.")
# 4.1) This step extracts the tnet from the rtni. The tnet is basically all genes (rows) and the TFs (columns). 
# Values represents the regulation of a certain gene by a given TF.
tnet <- tni.get(rtni, what="tnet")
# 4.2) This other step shrink it, to get info only of the TFs stored in mr_list.
sub.tnet <- tnet[,colnames(tnet)%in%mra$PROBEID]
# 4.3) This lasso runs for all columns in sub.tnet (i.e., all of master regulators), getting the regulated genes for each TF.
# How so? All genes with 'regulation' value =/= 0 is retrieved and stored. The result of this lasso is a list. 
# Each position of the list is a data.frame, containing: 1) rownames (genes regulated by that especific TF), a column 
# (named after the TF), and the values are the specific 'regulation' value, for each gene present.
# All names are in probe ID format. Don't worry about that, it will be processed in the next script.
regulated.genes <- list()
for(i in 1:ncol(sub.tnet))
{
  diff <- which(sub.tnet[,i] != 0)
  regulated.genes[[i]] <- sub.tnet[diff,i]
  temp <- as.data.frame(regulated.genes[[i]])
  colnames(temp) <- colnames(sub.tnet)[i]
  regulated.genes[[i]] <- temp
  rm(temp)
}
# 4.4 The steps below (save and load) are checkpoints. If is necessary to re-do the analysis, parts of the
# data is stored in RData and can be loaded to speed up the re-analysis.
save(regulated.genes, symbols.subtnet, file="regulatedGenes.RData")